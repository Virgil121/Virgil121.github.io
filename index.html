<!DOCTYPE html> 
<html style="background-color:lightgray">
<head>
<meta charset="UTF-8">
<title>Bezier vers Tikz</title>
<script type="text/javascript">

"use strict";

var cubicCanvas;
var cubicGraphics;
var cubicPoints;

var cubicHideSelect;
var lockSelect;
var precisionSelect;
var smartInsertionSelect;
var tikzPreambleSelect;
var tikzLabelsSelect;
var tikzSubGridSelect;
var tikzStartEndPointsSelect;
var tikzCubicLabelSelect;

var cubicCanvasWidth=1200;
var cubicCanvasHeight=800;
var pixelsUnit=50; // Espacement graduations
var subUnits=2; // Sous graduation
var p = 0; // Padding
var precisionSnap=0.1;
var pixelSnap=precisionSnap * pixelsUnit;

var xmin,xmax,ymin,ymax;

//
// CANVAS
//

function Point2D(x,y) {
    this.x = x;
    this.y = y;
}

function cubicDraw() {
    var i;
	// Size
	cubicGraphics.canvas.width=cubicCanvasWidth;
	cubicGraphics.canvas.height=cubicCanvasHeight;
	// Background
    cubicGraphics.fillStyle = "white";
    cubicGraphics.fillRect(0,0,cubicCanvasWidth,cubicCanvasHeight);
	// Secondary grid
	cubicGraphics.beginPath();
	for (var j = 0; j <= cubicCanvasWidth; j += pixelsUnit/subUnits) {
        cubicGraphics.moveTo(0.5 + j + p, p);
        cubicGraphics.lineTo(0.5 + j + p, cubicCanvasHeight + p);
    }
    for (var j = 0; j <= cubicCanvasHeight; j += pixelsUnit/subUnits) {
        cubicGraphics.moveTo(p, 0.5 + j + p);
        cubicGraphics.lineTo(cubicCanvasWidth + p, 0.5 + j + p);
    }
    cubicGraphics.setLineDash([5]);
	cubicGraphics.strokeStyle = "lightgrey";
	cubicGraphics.lineWidth = 1;
    cubicGraphics.stroke();
	cubicGraphics.setLineDash([]);
	// Main grid
	cubicGraphics.beginPath();
	for (var j = 0; j <= cubicCanvasWidth; j += pixelsUnit) {
        cubicGraphics.moveTo(0.5 + j + p, p);
        cubicGraphics.lineTo(0.5 + j + p, cubicCanvasHeight + p);
    }
    for (var j = 0; j <= cubicCanvasHeight; j += pixelsUnit) {
        cubicGraphics.moveTo(p, 0.5 + j + p);
        cubicGraphics.lineTo(cubicCanvasWidth + p, 0.5 + j + p);
    }
    cubicGraphics.strokeStyle = "lightgrey";
	cubicGraphics.lineWidth = 1;
    cubicGraphics.stroke();
	// Axes
	cubicGraphics.beginPath();
	cubicGraphics.moveTo(0,cubicCanvasHeight/2+0.5);
	cubicGraphics.lineTo(cubicCanvasWidth,cubicCanvasHeight/2+0.5);
	cubicGraphics.moveTo(cubicCanvasWidth/2+0.5,cubicCanvasHeight);
	cubicGraphics.lineTo(cubicCanvasWidth/2+0.5,0);
	cubicGraphics.strokeStyle = "#505050";
	cubicGraphics.lineWidth = 2;
	cubicGraphics.stroke();
	cubicGraphics.font='16px Arial';
	cubicGraphics.fillStyle = "black";
	cubicGraphics.textAlign = 'center';
	cubicGraphics.fillText(0,cubicCanvasWidth/2-10,cubicCanvasHeight/2+18);
	for (var j=1;j<21;j++) {
		cubicGraphics.fillText(j,cubicCanvasWidth/2+pixelsUnit*j,cubicCanvasHeight/2+18);
		cubicGraphics.fillText(j,cubicCanvasWidth/2-10,cubicCanvasHeight/2-pixelsUnit*j+8);
	}
	for (var j=-20;j<0;j++) {
		cubicGraphics.fillText(j,cubicCanvasWidth/2+pixelsUnit*j,cubicCanvasHeight/2+18);
		cubicGraphics.fillText(j,cubicCanvasWidth/2-14,cubicCanvasHeight/2-pixelsUnit*j+8);
	}
	// Control Points
    if ( ! cubicHideSelect.checked ) {
        cubicGraphics.lineWidth = 2;
		cubicGraphics.setLineDash([5,3]);
        if (lockSelect.checked) {
            cubicGraphics.strokeStyle = "#880000";   
        }
        else {
            cubicGraphics.strokeStyle = "#888888";
        }
        for (i = 0; i < cubicPoints.length - 1; i++) {
            if (i % 3 != 1) {
                cubicGraphics.beginPath();
                cubicGraphics.moveTo( cubicPoints[i].x + .5, cubicPoints[i].y + .5 );
                cubicGraphics.lineTo( cubicPoints[i+1].x + .5, cubicPoints[i+1].y + .5 );
                cubicGraphics.stroke();
            }
        }
        for (i = 0; i < cubicPoints.length; i++) {
            if ( i % 3 == 0 ) {
                cubicGraphics.fillStyle="black";
                disk(cubicGraphics, cubicPoints[i].x, cubicPoints[i].y, 5);
            }
            else {
                cubicGraphics.fillStyle= "blue";
                cubicGraphics.fillRect(cubicPoints[i].x - 5, cubicPoints[i].y - 5, 10, 10);
                
            }
        }
		cubicGraphics.setLineDash([]);
    }
	// Curve
    cubicGraphics.beginPath();
    cubicGraphics.moveTo(cubicPoints[0].x,cubicPoints[0].y);
    for (i = 1; i < cubicPoints.length; i += 3) {
        cubicGraphics.bezierCurveTo(cubicPoints[i].x,cubicPoints[i].y,
                              cubicPoints[i+1].x,cubicPoints[i+1].y,
                              cubicPoints[i+2].x,cubicPoints[i+2].y);
    }
    cubicGraphics.lineWidth = 2;
    cubicGraphics.strokeStyle = "black";
    cubicGraphics.stroke();
	printTikzCode();
}

function disk( graphics, x, y, radius ) {
    graphics.beginPath();
    graphics.arc(x,y,radius,0,Math.PI*2);
    graphics.fill();
}

//
// TIKZ
//

function setLimits() {
	xmin=cubicPoints[0].x;
	xmax=cubicPoints[0].x;
	ymin=cubicPoints[0].y;
	ymax=cubicPoints[0].y;
	for (var i=3;i < cubicPoints.length;i=i+3) {
		var p=cubicPoints[i];
		if (p.x < xmin) {xmin = p.x}
		if (p.x > xmax) {xmax = p.x}
		if (p.y > ymin) {ymin = p.y} // Inversion, not an error
		if (p.y < ymax) {ymax = p.y}
	}
	xmin = Math.round(((xmin-cubicCanvasWidth/2)/pixelsUnit - 1));
	xmax = Math.round(((xmax-cubicCanvasWidth/2)/pixelsUnit + 1));
	ymin = Math.round(((cubicCanvasHeight/2-ymin)/pixelsUnit - 1));
	ymax = Math.round(((cubicCanvasHeight/2-ymax)/pixelsUnit + 1));
}

function pointToStr(point) {
	var x0 = (point.x-cubicCanvasWidth/2)/pixelsUnit;
	var y0 = (cubicCanvasHeight/2-point.y)/pixelsUnit;
	return("("+x0.toString()+","+y0.toString()+")")
}

function printTikzCode() {
	// \draw[line width=1.3pt] (-4,1) .. controls  (-3.5,0) and (-1.75,-2)
	//				 .. (-1,-2) node[pos=0,stylepointextremites] {} .. controls (0.25,-2) and (1.5,4) 
	//				 .. (3,4) .. controls (4,4) and (6,2.5) 
	//				 .. (7,1) node[pos=0.3,above right] {$\mathscr C_1$} node[pos=1,stylepointextremites] {};
	var res = "";
	if ( tikzPreambleSelect.checked ) {
		setLimits();
		res="&#92begin{tikzpicture}<br>%<br>% Limites du repère modifiables<br>&#92def&#92bezierXmin{"+xmin.toString()+"}<br>&#92def&#92bezierXmax{"+xmax.toString()+"}<br>&#92def&#92bezierYmin{"+ymin.toString()+"}<br>&#92def&#92bezierYmax{"+ymax.toString()+"}<br>%<br>% Grille<br>"
		if ( tikzSubGridSelect.checked ) {
			res = res + "&#92draw[step=0.5,densely dashed,line width=0.25pt,draw=black!20] (&#92bezierXmin,&#92bezierYmin) grid (&#92bezierXmax,&#92bezierYmax);<br>";
		}
		res = res + "&#92draw[step=1,densely dashed,line width=0.4pt,draw=black!30] (&#92bezierXmin,&#92bezierYmin) grid (&#92bezierXmax,&#92bezierYmax);<br>%<br>% Création des axes avec tkz-base<br>&#92tkzInit[xmin=&#92bezierXmin,xmax=&#92bezierXmax,ymin=&#92bezierYmin,ymax=&#92bezierYmax]<br>&#92tkzSetUpAxis[ticka=3.5pt,tickb=3.5pt]	%Taille graduations<br>"
		if ( tikzLabelsSelect.checked ) {
			res = res + "&#92tkzLabelX[font=&#92scriptsize,orig=false,fill=none] % Graduations X <br>&#92tkzLabelY[font=&#92scriptsize,orig=false,fill=none] % Graduations Y<br>";
		}
		res = res + "&#92tkzDrawX[right space=0pt,above left=4pt,font=&#92scriptsize] %Axe X<br>&#92tkzDrawY[up space=0pt,below right=4pt,font=&#92scriptsize] %Axe Y<br>&#92clip (&#92bezierXmin,&#92bezierYmin) rectangle (&#92bezierXmax,&#92bezierYmax);<br>%<br>% Courbe<br>%<br>";
	}
	res = res + "&#92draw[line width=1pt] ";
	for(var j=0;j<cubicPoints.length-1;j=j+3) {
		res=res + pointToStr(cubicPoints[j]);
		if ( j==3 && tikzStartEndPointsSelect.checked ) {
			res = res + " node[pos=0,circle,fill,inner sep=0.8pt] {}";
		}
		res = res + " .. controls " + pointToStr(cubicPoints[j+1]) + " and " + pointToStr(cubicPoints[j+2]);
		res = res + " .. ";
	}
	res = res + pointToStr(cubicPoints[cubicPoints.length-1]);
	if ( tikzCubicLabelSelect.checked ) {
		res = res + " node[font=&#92footnotesize,pos=0.5,above left] {$&#92mathscr C_f$}";
	}
	if ( tikzStartEndPointsSelect.checked ) {
		res = res + " node[pos=1,circle,fill,inner sep=0.8pt] {}";
	}
	res = res + ";";
	if ( tikzPreambleSelect.checked ) {
		res = res + "<br>&#92end{tikzpicture}";
	}
	document.getElementById("coordinates").innerHTML=res;
}

//
// EVENTS
//

function doLock() {
    if ( lockSelect.checked ) {
		for (var i=3;i<=cubicPoints.length - 3;i=i+3) {
			cubicPoints[i+1].x = 2*cubicPoints[i].x - cubicPoints[i-1].x;
			cubicPoints[i+1].y = 2*cubicPoints[i].y - cubicPoints[i-1].y;
			cubicPoints[i-1].x = 2*cubicPoints[i].x - cubicPoints[i+1].x;
			cubicPoints[i-1].y = 2*cubicPoints[i].y - cubicPoints[i+1].y;
		}
    }
    cubicDraw();
}

var draggingCubic = false;
var draggingCubicSpecial=false;
var draggingQuad = false;
var dragPointIndex;

function doMouseUp(evt) {
    draggingCubic = false;
	draggingCubicSpecial = false;
    draggingQuad = false;
}

function doCubicMouseDown(evt) {
    if (draggingCubic || draggingQuad || cubicHideSelect.checked) {
        return;
    }
    var r = cubicCanvas.getBoundingClientRect();
    var x = Math.round(evt.clientX - r.left);
    var y = Math.round(evt.clientY - r.top);
    for (var i = cubicPoints.length - 1; i >= 0; i--) {
        var p = cubicPoints[i];
        if (Math.abs(p.x - x) <= 5 && Math.abs(p.y - y) <= 5) {
            draggingCubic = true;
			if (evt.shiftKey) {
				draggingCubicSpecial = true;
			}
            dragPointIndex = i;
            return;
        }
    }
}

function doCubicMouseDoubleClick(evt) {
    if (draggingCubic || draggingQuad || cubicHideSelect.checked) {
        return;
    }
	var r = cubicCanvas.getBoundingClientRect();
    var x = Math.round((evt.clientX - r.left)/pixelSnap)*pixelSnap;
    var y = Math.round((evt.clientY - r.top)/pixelSnap)*pixelSnap;
	var l = cubicPoints.length
	// Delete a point
	for (var i = 0; i < l; i=i+3) {
        var p = cubicPoints[i];
        if (Math.abs(p.x - x) <= 5 && Math.abs(p.y - y) <= 5) {
			// Cancel if there are not enough points
			if ( l <= 4 ) {
				return;
			}
			switch (i) {
				case l-1:
					cubicPoints.splice(l-3,3);
					break;
				case 0:
					cubicPoints.splice(0,3);
					break;
				default:
					cubicPoints.splice(i-1,3);
			}
			cubicDraw();
            return;
        }
    }
	// Create a point
	if (smartInsertionSelect.checked) {
		for (var i = 0; i < l; i=i+3) {
			var p = cubicPoints[i];
			if (p.x > x) {
				if (i==0) {
					cubicPoints.splice(0,0,new Point2D(x,y),new Point2D(x+50,y),new Point2D(2*cubicPoints[0].x-cubicPoints[1].x,2*cubicPoints[0].y-cubicPoints[1].y));
				}
				else {
					cubicPoints.splice(i-1,0,new Point2D(x-50,y), new Point2D(x,y), new Point2D(x+50,y));
				}
				cubicDraw();
				return;
			}
		}
		cubicPoints.push(new Point2D(2*cubicPoints[l-1].x-cubicPoints[l-2].x,2*cubicPoints[l-1].y-cubicPoints[l-2].y), new Point2D(x-50,y), new Point2D(x,y));
		cubicDraw();
	}
	else {
		cubicPoints.push(new Point2D(2*cubicPoints[l-1].x-cubicPoints[l-2].x,2*cubicPoints[l-1].y-cubicPoints[l-2].y), new Point2D(x-50,y), new Point2D(x,y));
		cubicDraw();
	}
}

function doCubicMouseMove(evt) {
    if (!draggingCubic) {
        return;
    }
    var r = cubicCanvas.getBoundingClientRect();
    var x = Math.round(evt.clientX - r.left);
    var y = Math.round(evt.clientY - r.top);
	if (precisionSelect.checked) {
		var offsetX = Math.round((x - cubicPoints[dragPointIndex].x)/pixelSnap)*pixelSnap;
		var offsetY = Math.round((y - cubicPoints[dragPointIndex].y)/pixelSnap)*pixelSnap;
	}
	else {
		var offsetX = x - cubicPoints[dragPointIndex].x;
		var offsetY = y - cubicPoints[dragPointIndex].y;
	}
	// If shiftKey is pressed, move an anchor freely but still aligned with the other anchor and the main point.
	// Else respect the lock
	if ( ((draggingCubicSpecial) || (evt.shiftKey )) && ((1 < dragPointIndex && dragPointIndex < cubicPoints.length - 2) && (dragPointIndex % 3 != 0)) ) {
		// Consider only the non extremal anchor points
		draggingCubicSpecial = true; // Stop the normal behavior if the shift key is pressed once
		if ( dragPointIndex % 3 == 1 ) {
			var p0 = cubicPoints[dragPointIndex - 1];
			var p1 = cubicPoints[dragPointIndex - 2];
		}
		else {
			var p0 = cubicPoints[dragPointIndex + 1];
			var p1 = cubicPoints[dragPointIndex + 2];
		}
		var U = ( ((x - p0.x) * (p1.x - p0.x)) + ((y - p0.y) * (p1.y - p0.y)) ) / ( Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2) );
		//if (precisionSelect.checked) {
		//	cubicPoints[dragPointIndex].x = p0.x + Math.round((U * (p1.x - p0.x))/pixelSnap)*pixelSnap;
		//	cubicPoints[dragPointIndex].y = p0.y + Math.round((U * (p1.y - p0.y))/pixelSnap)*pixelSnap;
		//}
		//else {
		//
		// Allow for more digits when using this mode to preserve the alignment
		cubicPoints[dragPointIndex].x = p0.x + Math.round((U * (p1.x - p0.x)));
		cubicPoints[dragPointIndex].y = p0.y + Math.round((U * (p1.y - p0.y)));
		//}
	}
	else {
		cubicPoints[dragPointIndex].x += offsetX;
		cubicPoints[dragPointIndex].y += offsetY;
		if ( dragPointIndex % 3 == 0) {
			if (dragPointIndex > 0) {
				cubicPoints[dragPointIndex - 1].x += offsetX;
				cubicPoints[dragPointIndex - 1].y += offsetY;
			}
			if (dragPointIndex < cubicPoints.length - 1) {
				cubicPoints[dragPointIndex + 1].x += offsetX;
				cubicPoints[dragPointIndex + 1].y += offsetY;
			}
		}
		else if (lockSelect.checked) {
			for (var i=3;i<= cubicPoints.length - 3;i=i+3) {
				if (dragPointIndex == i-1) {
					cubicPoints[i+1].x = 2*cubicPoints[i].x - cubicPoints[i-1].x;
					cubicPoints[i+1].y = 2*cubicPoints[i].y - cubicPoints[i-1].y;
				}
				else if (dragPointIndex == i+1) {
				   cubicPoints[i-1].x = 2*cubicPoints[i].x - cubicPoints[i+1].x;
				   cubicPoints[i-1].y = 2*cubicPoints[i].y - cubicPoints[i+1].y;
				}
			}
		}
	}
    cubicDraw();
}

function snapPoints() {
	if ( precisionSelect.checked ) {
		for (var j=0;j<cubicPoints.length;j++) {
			cubicPoints[j].x = pixelSnap*Math.round(cubicPoints[j].x/pixelSnap);
			cubicPoints[j].y = pixelSnap*Math.round(cubicPoints[j].y/pixelSnap);
		}
	}
	cubicDraw();
}

function init() {
    try {
        cubicCanvas = document.getElementById("cubic");
        cubicGraphics = cubicCanvas.getContext("2d");
    }
    catch (e) {
        var message = document.getElementById("message");
        message.innerHTML = "Oops... Sorry, your browser doesn't support the canvas element.";
        return;
    }
	
    lockSelect = document.getElementById("lock");
    lockSelect.checked = true;
    lockSelect.onclick = doLock;
	precisionSelect = document.getElementById("precision");
	precisionSelect.checked = true;
	precisionSelect.onclick = function() { snapPoints(); };
	smartInsertionSelect = document.getElementById("smartInsertion");
	smartInsertionSelect.checked = true;
    cubicHideSelect = document.getElementById("cubicHide");
    cubicHideSelect.checked = false;
    cubicHideSelect.onclick = function() { cubicDraw(); };
	tikzPreambleSelect = document.getElementById("tikzPreamble");
	tikzPreambleSelect.checked = true;
	tikzPreambleSelect.onclick = function() { printTikzCode(); };
	tikzLabelsSelect = document.getElementById("tikzLabels");
	tikzLabelsSelect.checked = true;
	tikzLabelsSelect.onclick = function() { printTikzCode(); };
	tikzSubGridSelect = document.getElementById("tikzSubGrid");
	tikzSubGridSelect.checked = true;
	tikzSubGridSelect.onclick = function() { printTikzCode(); };
	tikzStartEndPointsSelect = document.getElementById("tikzStartEndPoints");
	tikzStartEndPointsSelect.checked = false;
	tikzStartEndPointsSelect.onclick = function() { printTikzCode(); };	
	tikzCubicLabelSelect = document.getElementById("tikzCubicLabel");
	tikzCubicLabelSelect.checked = true;
	tikzCubicLabelSelect.onclick = function() { printTikzCode(); };	
    cubicPoints = [
        new Point2D(350,450),  new Point2D(450,550),
        new Point2D(450,200), new Point2D(500,200), new Point2D(550,200),
        new Point2D(525,500), new Point2D(625,500), new Point2D(725,500),
        new Point2D(775,200), new Point2D(850,275)
    ];
    cubicDraw();
    document.addEventListener("mouseup", doMouseUp, false);
    cubicCanvas.addEventListener("mousedown", doCubicMouseDown, false);
    cubicCanvas.addEventListener("mousemove", doCubicMouseMove, false);
	cubicCanvas.addEventListener("dblclick", doCubicMouseDoubleClick, false);
};
</script>
</head>
<body onload="init()" style="background-color: ivory; width:1200px; margin:0px auto; padding:30px;">

<noscript><p style="color:red">Sorry, this page requires JavaScript to run.</p></noscript>

<!--[if lt IE 9]>
<hr>
<p style="color:red">Sorry, this page uses HTML canvas.<br>
Canvas is not supported in Internet Explorer 8 or earlier.<br>
Please use a newer version or a different browser.</p>
<hr>
<![endif]-->

   
<h1>Editeur de courbe de Bezier avec export Tikz</h1>

<p id="message" style="font-weight: bold"></p>

<p>
Pour insérer ou supprimer un point, il suffit de double-cliquer.
<ul>
<li> Le mode intelligent permet d'insérer un nouveau point dans une courbe existente. Il ne fonctionne correctement que si les points de contrôle principaux (noirs) sont classés par abscisses croissantes (utile pour représenter des fonctions f:R -> R). S'il est désactivé, les nouveaux points sont ajoutés après le dernier. </li>
<li> (Déconseillé) On peut déverouiller les points de contrôle pour les ajuster indépendamment, mais la courbe sera alors moins régulière. </li>
<li> Appuyer sur Shift (Maj) avant ou pendant le déplacement d'un point de contrôle secondaire permet de le déplacer sur la tangente, permettant de garder une certaine régularité tout en ayant un contrôle plus fin. </li>
</ul>
</p>

<p style="font-weight: bold">
<input type="checkbox" id="lock"> <label for="lock" style="margin-right:1cm">Verrouiller les paires de points de contrôle</label>
<input type="checkbox" id="cubicHide"> <label for="cubicHide" style="margin-right:1cm">Cacher les contrôles</label>
<input type="checkbox" id="precision"> <label for="precision" style="margin-right:1cm">Mode une décimale</label>
<input type="checkbox" id="smartInsertion"> <label for="smartInsertion">Insertion intelligente (compare les abscisses)</label>
</p>

<canvas id="cubic" style="background-color: white; border: thin solid black"></canvas>

<h2> Export Tikz </h2>

<h3> Environnement Tikz </h3>

<p style="font-weight: bold">
<input type="checkbox" id="tikzPreamble"> <label for="tikzPreamble" style="margin-right:1cm">Générer l'environnement tikzpicture entier (ajustements sur les limites du graphiques à prévoir)</label>
<input type="checkbox" id="tikzLabels"> <label for="tikzLabels" style="margin-right:1cm">Graduations</label>
<input type="checkbox" id="tikzSubGrid"> <label for="tikzSubGrid" style="margin-right:1cm">Sous-grille</label>
</p>

<h3> Propriétés de la courbe </h3>

<p style="font-weight: bold">
<input type="checkbox" id="tikzStartEndPoints"> <label for="tikzStartEndPoints" style="margin-right:1cm">Insérer des points aux extrémités de la courbe</label>
<input type="checkbox" id="tikzCubicLabel"> <label for="tikzCubicLabel" style="margin-right:1cm">Insérer un label sur la dernière portion de la courbe (position à ajuster à la main)</label>
</p>

<p id="coordinates" style="background-color:white; padding:5px; border-color:black; border:1px solid; font-size: 12px; height: 500px"> </p>

<p style="font-style=italic;margin-top:1cm;"> v1.0 - Basé sur <a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">Bezier Curve Demos</a> </p>

</body>
</html>

